
리액트를 공부하던 중 바벨의 트랜스파일 과정에서 `async/await` 구문이 `제너레이터`로 변환된다는 사실을 알게 되었다. 이 내용이 좀 신기하고 자세히 알고싶었고, 이걸 찾아서 공부하다 보니 내가 `제너레이터`나 `이터레이터`, `async/awiat` 등에 대한 이해가 좀 부족하다는 생각이 들었다. 그래서 자바스크립트의 `async/await`, `async 이터레이터`, `제너레이터` 에 대해 정리해보고자 한다.

## 1. 제너레이터

### 제너레이터 함수
### 제너레이터와 이터러블
### 제너레이터 컴포지션
### yield를 사용해 제너레이터 안/밖으로 정보 교환하기

<br><br>

## 2. async await

## 3. async 이터레이터
`async 이터레이터`를 알아보기 전에 먼저 `이터러블`에 대해 알아본다.

### 3.1 이터러블 객체
`이터러블` 객체를 알기 위해서는 `이터레이션`, `이터러블`, `이터레이터` 세가지를 알아야한다. 이름이 비슷해서 햇갈릴 가능성이 높다.

`이터레이션` 프로토콜은 ECMAScript에서 정의한 순회 가능한 컬렉션을 만들기 위한 규칙이다. `이터레이션` 프로토콜에는 `이터러블`, `이터레이터` 프로토콜이 있다.
- `이터러블`을 만족하는 객체는 `Symbol.iterator` 프로퍼티 키로 메서드를 호출하면 `이터레이터` 프로토콜을 준수하는하는 이터레이터 객체를 반환해야 한다.
- `이터레이터` 프로토콜을 만족하는 객체는 `next` 메서드를 가지고, 이를 호출하면 `value`, `done`프로퍼티를 갖는 `Iterator Result` 객체를 반환해야한다.

`이터러블` 프로토콜을 준수하는 객체는 `for...of`문 순회나 스프레드 문법, 배열 디스트럭처링 할당문의 대상이 될 수 있다.

위 프로토콜을 이용해 1~5의 값을 `for...of` 문으로 순회하여 조회할 수 있는 간단한 `이터러블 객체`를 만들어 본다.

```js
const range = {
  from: 1,
  to: 5,
  [Symbol.iterator]() {
    return {
      current: this.from,
      to: this.to,
      next() {
        if(this.current > this.to) {
          return { done: true };
        } 
        return { value: this.current++, done: false};
      }
    }
  }
}

for(let num of range) {
  console.log(num); // 1 2 3 4 5
}
console.log(...range) // 1 2 3 4 5
```

위 코드에서 이터러블 객체에 `for...of` 문이나 스프레드 문법을 사용하면 내부적으로 
  1. `Symbol.iterator` 프로퍼티 키로 메서드를 찾아 호출해 이터레이터 객체를 취득하고, 
  2. 이터레이터 객체의 `next` 메서드를 `{done: true}`가 반환될 때 까지 호출해 순회
하는 과정을 거치게 된다.

<br>

### 3.2 async 이터레이터
이터러블 객체는 **동기**적으로 작동한다. 이터러블에 비동기 이터레이터(async Iterator)를 사용하면 비동기적으로 들어오는 데이터를 처리할 수 있게 된다. 

비동기로 동작하는 이터러블 객체를 만들려면, 아래와 같은 내용을 준수해야한다.
- `Symbol.iterator` 대신 `Symbol.asyncIterator`를 사용한다.
- 이터레이터 객체의 `next()` 메서드는 `Promise`를 반환해야한다.
- 비동기 이터러블 객체의 순회는 `for await ... of`문을 사용해야 한다.

'3.1'에서 만든 이터러블 객체 range를 약간 변형해서 비동기로 동작하게 만들어 본다. 1초에 한번씩 순회하게 만든다.
```js
const range = {
  from: 1,
  to: 5,
  [Symbol.asyncIterator]() {  // Symbol.asyncIterator 사용
    return {
      current: this.from,
      to: this.to,
      async next() {  // async 키워드를 사용해 반환되는 값이 Promise가 되게 만든다.

        await new Prmoise(resolve => setInterval(resolve, 1000)); // 1초의 시간 지연을 위한 코드

        if(this.current > this.to) {
          return { done: true };  
        } 
        return { value: this.current++, done: false};
      }
    }
  }
}

(async () => {  // await 키워드로 순회하려면 async 키워드는 필수
  for await (let num of range) {  // for await of 문으로 순회한다.
    console.log(num);  // 1 (1초뒤) 2 (1초뒤) ... 5
  }
})()

console.log(...range);  // Uncaught TypeError: Found non-callable @@iterator
```

이렇게 `async 이터레이터`객체를 반환하는 이터러블 객체는 아쉽게도 ***스프레드 문법으로는 순회 불가능하다.***

### 3.3 async 제너레이터
### 3.4 async 이터러블