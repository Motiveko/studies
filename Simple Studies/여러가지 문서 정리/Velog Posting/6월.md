# 6월

## node-sass 설치에러, nvm
- 카카오 전사 에디터 demo를 확인해보려고 프로젝트 클론 후 `npm i`를 하니 `node-sass`관련해서 에러가 난다고 나온다.
- 원인은 node 버전별로 node-sass 지원 버전이 달라지는데, 내 로컬은 `node v16`였고 프로젝트는 `node-sass@^4.9.0`로 서로 지원이 안되는 버전이었던 것이다. 노드 버전을 14로 맞춰야한다.
  - https://velog.io/@somangoi/node-sass-node-gyp-%EC%97%90%EB%9F%AC%EB%A1%9C-%EC%9D%B8%ED%95%B4-npm-install%EC%9D%B4-%EC%95%88%EB%90%9C%EB%8B%A4%EB%A9%B4
- 로컬의 노드를 지우고 v14를 설치한 후 쓸수도 있겠으나 고작 데모를 열자고 내 보드를 낮출 순 없었다. `nvm`을 사용하면 노드 버전 스위칭이 가능하다.
  - https://dev-yakuza.posstree.com/ko/environment/nvm/
  - `.nvmrc` 파일을 이용해 프로젝트별로 node version 관리도 가능하다

<br>

## 디스럭처링 문법
- 작업중 객체 디스트럭처링을 재할당 해야 하는 코드를 작성할 일이 생겼다
```ts
let {notices, isEmpty}: CheckNoticeState = yield select(selectCheckNoticeStatus);

if (notices.length === 0 && !isEmpty) {
  yield call(_getCheckNoticeList);
  {notices, isEmpty} = yield select(selectCheckNoticeStatus); // Error 선언 또는 문이 필요합니다. 이 '='은 문 블록을 따르므로 구조 파괴 할당을 작성하려는 경우 전체 할당을 괄호로 묶어야 할 수 있습니다.ts(2809)
}
```
- 즉 재할당문을 아래와 같이 바꿔야한다.
```ts
({notices, isEmpty} = yield select(selectCheckNoticeStatus));
```
- 배열은 상관 없으나 객체 디스트럭처링의 경우 `let`,`const`,`var`가 없으면 `{...}`를 객체 리터럴이 아닌 `블록`으로 간주하기 때문에 expression context (`(...)`)내부에서 작성해야만 한다.
- 참고
  - https://stackoverflow.com/questions/48714689/javascript-re-assign-let-variable-with-destructuring
  - https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#%EA%B0%9D%EC%B2%B4_%EA%B5%AC%EC%A1%B0_%EB%B6%84%ED%95%B4


<br>

## 리액트 커스텀 훅 테스팅
- 리액트 훅은 컴포넌트 내부에서만 쓸 수 있기 때문에 커스텀 훅을 테스트하려면 일반적으로 **'커스텀 훅을 사용하는 컴포넌트를 랜더링'**해서 간접적으로 테스트해야한다.
- 그러나 [`@testing-library/react-hooks`](https://www.npmjs.com/package/@testing-library/react-hooks) 라이브러리를 사용하면 따로 컴포넌트 랜더링 하지 않고도 훅 자체만 테스트가 가능하다.(물론 내부적으로는 랜더링이 이뤄진다.)
```js
// useCounter.js
import { useState, useCallback } from 'react'

function useCounter() {
  const [count, setCount] = useState(0)

  const increment = useCallback(() => setCount((x) => x + 1), [])

  return { count, increment }
}

export default useCounter
```
```js
// useCounter.test.js
import { renderHook, act } from '@testing-library/react-hooks'
import useCounter from './useCounter'

test('should increment counter', () => {
  const { result } = renderHook(() => useCounter())

  act(() => {
    result.current.increment()
  })

  expect(result.current.count).toBe(1)
})
```
- `act()` 메서드를 사용해서 상태 변경을 일으키면 렌더링을 다시 할 수 있다.

<br>

## @testing-library/react 
- `React v17` 환경에서 `@testing-library/react v13`의 render 메서드로 컴포넌트 랜더링시 랜더링이 안되는 문제가 있었다. `@testing-library/react v12`로 버전을 낮추니 바로 정상동작하는데 아마 버전 관련 이슈인듯 하다. 찾아서 정리필요


<br>

## createSelector 사용간의 유의사항
- `createSelector()`에 인자를 전달할 때 객체를 전달하는것은 무한 랜더링을 일으킬 여지가 있다.
```ts
// 문제가 있는 셀렉터
type SelectCheckNoticeBySearchTextAndPageArgs = {
  searchText: string;
  currentPage: number;
  pageSize: number;
};
const selectNoticeBySearchTextAndPage = createSelector(
  [
    (state: RootState) => state,
    (
      state,
      {
        searchText,
        currentPage,
        pageSize,
      }: SelectCheckNoticeBySearchTextAndPageArgs,
    ) => ({
      searchText,
      current: currentPage,
      pageSize,
    }),
  ],
  (state, {searchText, pageSize, current}) => {
    const start = pageSize * (current - 1);
    return selectNoticesBySearchText(state, searchText).slice(
      start,
      start + pageSize,
    );
  },
);
```

```ts
// 셀렉터를 사용하는 컴포넌트 코드
const {totalCount, notices} = useSelector((state: RootState) => ({
  totalCount: selectors.selectNoticesBySearchText(state, searchText).length,
  notices: selectors.selectNoticeBySearchTextAndPage(state, {
    searchText,
    currentPage,
    pageSize,
  }),
}, shallowEqual);

// ... 

const [selectedArray, setSelectedArray] = useState<boolean[]>([]);
useEffect(() => {
  const {length} = notices;
  setSelectedArray(Array.from({length}, () => false));
}, [notices]);

// ...
```
- 문제의 과정은 아래와 같다.
  1. `useEffect`훅에서 `notices`변화가 감지되면 `setSelectedArray()`로 컴포넌트 상태를 변경한다.
  2. 상태 변경으로 리랜더링 발생
  3. `useSelector` 호출
  4. `selectNoticeBySearchTextAndPage()`의 인자 전달값 `{searchText,currentPage,pageSize}`은 내부 값에 상관없이 새로운 객체 생성
  5. 셀렉터에서는 인자로 새로운 객체가 전달되었으므로 셀렉트 로직 재실생. `Array.prototype.slice()`로 생성한 값을 반환하는데 이 메서드는 원본을 바꾸지 않고 새로운 배열을 생성해서 반환한다.
  6. 컴포넌트에서 참조하는 notices는 새로운 참조를 지닌 배열이다.
  7. `1.`의 `useEffect`훅이 변화를 감지. 1~7 계속 무한반복

- 매번 객체 리터럴로 새로운 값을 전달하면 `메모아이제이션`이 작동하지 않아 새로운 값을 반환할 가능성이 생긴다. 아래와 같이 셀렉터를 바꿔서 문제를 해결한다.

```ts
// 개선 후
const selectNoticeBySearchTextAndPage = createSelector(
  [
    (state: RootState) => state,
    (state, searchText: string, currentPage: number, pageSize: number) => ({
      searchText,
      current: currentPage,
      pageSize,
    }),
  ],
  (state, {searchText, pageSize, current}) => {
    const start = pageSize * (current - 1);
    return selectNoticesBySearchText(state, searchText).slice(
      start,
      start + pageSize,
    );
  },
);
```
- `1. ~ 3.` 동일
  - 4. `selectNoticeBySearchTextAndPage()`의 인자로 전달한 값들은 단순비교로 비교해서 변하지 않았다. 메모된 배열 반환.
  - 5. 컴포넌트에서는 `notices`가 변경되지 않았기 때문에 `useEffect`훅은 동작하지 않는다.