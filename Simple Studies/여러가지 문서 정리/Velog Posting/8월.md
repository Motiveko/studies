## 몇가지 css 속성
- [`text-shadow`](https://developer.mozilla.org/ko/docs/Web/CSS/text-shadow)
  - text와 [text-decoration](https://developer.mozilla.org/en-US/docs/Web/CSS/text-decoration)에 그림자를 추가한다. text-decoration은 밑줄같은걸 말한다.
  - `text-decoration: offset-x | offset-y | blur-radius | color `으로  `box-shadow`랑 문법 비슷하다.

<br>

- [`attr`](https://developer.mozilla.org/en-US/docs/Web/CSS/attr)
  - css가 적용된 HTML요소의 attribute값을 css에서 쓸 수 있도록 하는 [`css 함수`](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Functions)이다. `::before`, `::backdrop`같은 [`css pseudo element`](https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements)에 적용할 수 있고, 이 때 의사 요소의 원본 요소의 attribute 값을 참조하게 된다.
  ```css
  /* 기본값 */
  attr(data-count);

  /* 단위 적용, 생략시 string이다 */
  attr(src url);
  attr(data-count number);
  attr(data-width px);

  /* fallback(기본값) 적용 */
  attr(data-count number, 0);
  attr(src url, "");
  ```

<br>

- [`clip-path`](https://developer.mozilla.org/ko/docs/Web/CSS/clip-path)
  - 적용된 HTML 요소의 클리핑 범위를 지정한다. 클리핑 범위 내부는 화면에 보여지고, 범위 밖은 보이지 않는다.
    ```css
    /* <clip-source> 값 */
    clip-path: url(resources.svg#c1);

    /* <geometry-box> 값 */
    clip-path: margin-box;
    clip-path: border-box;
    ...

    /* <basic-shape> 값 */
    clip-path: inset(100px 50px);
    clip-path: circle(50px at 0 100px);
    ...

    /* 박스와 도형 값 조합 */
    clip-path: padding-box circle(50px at 0 100px);

    /* 전역 값 */
    clip-path: inherit;
    clip-path: initial;
    clip-path: unset;
    ```

  - [clip path generator](https://www.cssportal.com/css-clip-path-generator/)를 이용하면 편안하게 gui를 통해 원하는 형태의 clip path를 만들어서 코드로 얻을 수 있다.

<br>

- [`skew()`](https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/skew)
  - skew는 번역하면 '왜곡하다','비스듬히 움직이다.' 이다. 
  ```css
  /* x축으로(가로) 비튼다 */
  transform: skew(ax);

  /* x축과 함께 y축(세로)로 비튼다. ax를 0으로 하면 세로만 비틀겠죠? */
  transform: skew(ax, ay);
  ```
  - 참고로 `90deg`로 비틀면 길이가 무한정 늘어나면서 요소의 넓이(x축일경우, y축은 높이)가 0이 되면서 안보이게 된다.
  `

<br>

<!-- TODO : 여기서부터.. -->
- [`will-change`](https://developer.mozilla.org/ko/docs/Web/CSS/will-change)
  - https://flamingotiger.github.io/style/css-will-change/
  - css의 `transform`, `animataion` 같은 프로퍼티 사용시 화면이 순간 끊기는 현상같은게 발생할 수있다.
  - `will-chagne` 속성을 이용해서 `transform` 등의 값이 변할것을 브라우저에 미리 알려주면(hint) 브라우저가 해당 작업을 미리 실행해놓고 GPU 가속을 사용해 최적화를 할 수 있게 된다.
  - 자세한건 좀 더 알아보자..

- [`mix-blend-mode`](https://developer.mozilla.org/ko/docs/Web/CSS/mix-blend-mode)
  - https://hyoni-k.tistory.com/48
  - 이미지 등 요소가 겹치는 부분에 대해서 어떻게 표현할 것인지를 정하는 css 속성이다.
  - 일반적으로 겹치면 `normal`로 z-index가 위에있는애만 표시되는데, `darken`을 하면 검게 보이게 하고 `difference`를 하면 반전된 색상으로 보여주고 ... 뭐 그런거라고 한다. 포토샵에도 이런거랑 비슷한 blend mode가 있다고함.


<br>

## 타입스크립트 - 특정 객체의 값들을 뽑아 타입으로 만들기
```ts
export const COLORS = {
  PRIMARY: 'primary',
  SECONDARY: 'secondary',
  SUCCESS: 'success',
  // ...
} as const;
```
- `COLORS`라는 `{key:value}` 객체가 있다. 컴포넌트의 props로 `'primary'`, `'secondary'` 같은 값을 전달하려고 하고, 사용하는 쪽에서는 이걸 `COLORS.PRIMARY` 같은 형태로 전달하는게 목적이다. props의 타입은 결국 COLORS 객체의 값이다. 간단하겐 아래와 같이 만들 수 있따.

```ts
export type COLOR = typeof COLORS[keyof typeof COLORS]; // => 타입은 string!
```

- 근데 문제는 타입스크립트에서는 `COLORS` 객체 속성들의 변경이 가능하다고 생각해서 `string`으로 퉁쳐서 인식하는 것 같다. `as const`로 COLORS에 단언을 적용하면 해결할 수 있다.

```ts
export const COLORS = {
  ....
} as const;
export type COLOR = typeof COLORS[keyof typeof COLORS]; // 'primary' | 'secondary' | ...
```

- 이렇게 `매핑된 타입`을 만들면 'primary', 'secondary' 같은 값을 두번 작성하지 않고도 값을 공유하는 타입을 만들 수 있다.