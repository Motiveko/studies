## 몇가지 css 속성 정리
1. [`-webkit-text-stroke`](https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-text-stroke)
- 비표준이다. 
- 텍스트의 stroke(외곽선)에 대한 width, color 에대한 속성이다.
```css
/* usage */
{
  /* Width and color values */
  -webkit-text-stroke: 4px navy;
  text-stroke: 4px navy;

  /* Global values */
  -webkit-text-stroke: inherit;
  text-stroke: inherit;
}
```

<br>

2. [`background-clip`](https://developer.mozilla.org/ko/docs/Web/CSS/background-clip)
- 배경(background)가 요소의 어디까지 차지할 지 지정한다.
  - `border-box`: 요소의 border까지 차지
  - `padding-box`: 요소의 border만 제외, 패딩 포함한 크기만큼 차지
  - `content-box`: 요소의 border, padding 제외, content 크기만큼 차지
  - `text`: 요소의 텍스트 크기만큼 차지(텍스트 애니메이션에 유용)

<br>

3. [`background-position`](https://developer.mozilla.org/en-US/docs/Web/CSS/background-position)과 [`background-size`](https://developer.mozilla.org/en-US/docs/Web/CSS/background-size)
- 백그라운드 배치 위치와 크기를 정의한다.
- `background-position`는 기본 `0`(== left top)인데, 이 지점이 background size가 변하는 기준점이 된다. 0에서는 background-size가 커지면 'right bottom' 방향으로 커짐
- `background-position : center`라면 background-size가 상하좌우로 커지고 줄어든다.
- ***배경 단순 배치라면 직관적이지만, background-size 애니메이션 적용시 background-position에 따라 사이즈 변화 방향이 결정된다는게 중요***

<br>

4. [`filter`](https://developer.mozilla.org/ko/docs/Web/CSS/filter)
- `filter` 속성은 흐림효과, 색상 변경 등 그래픽 효과를 적용한다. 
- [css function](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Functions)값을 사용할수있음
  - `url(url)`: svg 필터를 가리키는 URL을 지정해 필터 적용 가능
  - `blur(px)`: 흐리게
  - `contrast(%)`: 대비 증가
  - `grayscale(%)`: 흑백효과
  - `drop-shadow(x y radius color)`: 그림자 효과를 준다
  - `brightness`, `opacity`...등등 css

<br>

## HTML String to DOM
- string을 DOM으로 바꾸는 방법은 여러가지가 있다. 가장 심플한 방법은 [`DOMParser API`](https://developer.mozilla.org/ko/docs/Web/API/DOMParser)를 쓰는것이다.
```js
const htmlString = '<div class="content"><span>hello</span></div>';
const ConvertStringToHTML = (htmlString) => {
   const parser = new DOMParser();
   const doc = parser.parseFromString(htmlString, 'text/html');
   return doc.body;
};
console.log(ConvertStringToHTML(htmlString));

```
![결과](https://velog.velcdn.com/images/motiveko/post/f0db0813-f075-48a8-8204-90bd0167155b/image.png)

- `parseFromString()` 메서드 결과는 `Document` 객체로 `<html>`요소라고 보면 된다. 결과값은 body에 들어가므로 `doc.body`를 반환하였다.

<br>

- 다른 방법으로는 `document.createElement(TYPE)`으로 노드를 만들고 innerHTML로 string을 넘겨준 후 이 요소의 자식 요소에 접근하는 방식도 있겠다. 그래도 `parseFromString()`이라는 존재 목적이 분명한 native api를 사용하는게 좋겠다.

<br>

## [Element.getBoundingClientRect()](https://developer.mozilla.org/ko/docs/Web/API/Element/getBoundingClientRect)
- DOM 요소의 사이즈나 뷰포트의 위치 등을 가져올 수 있는 유용한 API다. 요소에 여러가지 이펙트를 걸 때 위치값을 계산하는데 쓸 수 있다.
- 반환값은 [`DOMRect`](https://developer.mozilla.org/ko/docs/Web/API/DOMRect) 객체다.  
  - `x`,`y` : 왼쪽 위 꼭지점의 뷰포트상 좌표, 뷰표트에 요소가 있으면 둘다 양수값(스크롤 등으로 안보이면 음수)
  - `width`, `height`: 요소의 border-box 넓이/높이. 즉 content + padding + border 값이다. 스타일에서 `box-style: border-box`로 지정했을 경우 width/height값과 동일하다.
  - `top`: 요소의 윗 모서리(윗면)의 뷰포트상 위치. height가 양수면 y와 동일
  - `bottom`: 요소의 아랫 모서리(아랫면)의 뷰포트상 위치. height가 양수면 y + height와 같다.
  - `left`: 요소의 왼쪽 모서리(왼쪽면)의 뷰포트상 위치. width가 양수면 x와 동일
  - `right`: 요소의 아래쪽 모서리(아래면)의 뷰포트상 위치.  width가 양수면 x + width와 같다.
![domrect](https://developer.mozilla.org/ko/docs/Web/API/Element/getBoundingClientRect/element-box-diagram.png)


<br>

## DOM 요소에 자바스크립트로 css 변수 전달하기
- DOM 요소에서 css 변수값을 사용하고, 이를 자바스크립트를 이용해 동적으로 할당하고 싶을 때가 있다. 아래와 같이 사용하면 된다.
```html
<!DOCTYPE html>
<html lang="en">

<head>
  <style>
    button {
      color: var(--color);
    }
  </style>
</head>

<body>
  <button id="btn">버튼</button>

  <script>
    const button = document.getElementById('btn');

    let isRed = true;
    button.addEventListener('click', () => {
      const color = isRed ? 'red' : 'blue';
      button.style.setProperty('--color', color);
      isRed = false;
    })
  </script>
</body>

</html>
```
- 최초에는 `--color`에 아무 값이 없으므로 글자색은 까만색이다. 버튼 클릭시마다 css 변수 `--color`에는 `red`, `blue`값이 번갈아 가며 할당된다. **이 때 해당 값은 DOM 요소에 inline으로 적용되어, 다른 요소의 `--color`값에는 영향을 주지 않는다.** 따라서 해당 요소와 자식요소, `:before`, `:after`등에서 자유롭게 쓰면 된다.
![css variable](https://velog.velcdn.com/images/motiveko/post/34e070d0-fa99-4594-a08f-f57953dfd9f2/image.png)

<br>

## [CSS Gradient](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Images/Using_CSS_gradients)
css에 이미지 관련 속성(대표적으로 background)에 쓸 수 있는 `gradient`에는 3가지 종류가 있다. 여러가지 색상의 그라데이션을 표현한다.

<br>

1. [`radial-gradient`](https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/radial-gradient): 두가지 이상 색상의 (타)원형 그라데이션이다.
2. [`linear-gradient`](https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/linear-gradient) : 두가지 이상 색상읜 선형 그라데이션이다.
3. [`conic-gradient`](https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/conic-gradient) : 두가지 이상 색상의 원뿔형 그라데이션이다.
- `position`, `ending-shape`, `size`, `linear-color-stop`, `color-hint`같은 속성의 조합으로 이뤄진다.
- 색상: `color start end` 같은 형태로 색상 띠를 만들수 있고
- 위치/방향 : `to top`, `to bottom left`, `70deg` 같은 형태로 그라데이션 진행 방향이나 포지션을 나타낼 수 있다. gradient 종류별로 명칭이 좀씩 달라진다.
- [오버레이 그라디언트](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Images/Using_CSS_gradients#overlaying_gradients): 이미지에다 그라디언트를 입힐수 있다. 색도 지정 가능하고 `transparent`같은 속성으로 `opacitiy` 비슷한걸 조절하는것두 가능하다.
- 기타등등 문법과 활용방향이 많은데, 복잡하므로 그라데이션을 만들어야 할 때 찾아서 써보자!

<br>

### [Scale](https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/scale) vs [Scale3d](https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/scale3d)

- 둘다 크기를 조절하는 css 함수다. 차이는 `Scale`은 x,y 벡터로 크기를 변형할 수 있다면, `Scale3d`는 z 벡터까지 사용할 수 있다는 것이다.(축이 3개라는것)
- ***일반적인 평면 요소에는 `Scale(1.5, 1.5)`와 `Scale3d(1.5, 1.5,1.5)`의 결과가 같은데, `rotate3d()` 함수를 써서 3d로 표현되는 요소는 `Scale()`로 키우면 입체적인게 그대로 표현되지 않는다.***
  ![scale](https://velog.velcdn.com/images/motiveko/post/0c097c06-bcf5-44ae-b626-34a1cf2f6271/image.png)

- Scale(1.5,1.5)는 뭔가 축이 돌아가버린 느낌으로 커지는걸 확인할 수 있다.

<br>

### SVG 사이즈 변경하기
> [SVG(Scalable Vector Graphics)](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute)는 벡터 그래픽으로, 픽셀을 이용해 그래픽을 표현하는 `jpg`, `png`등과 다르게 ***벡터를 기반으로 이미지를 표현하는 방식이다.*** 벡터는 수학적으로 좌표를 만들어서 그래픽을 표현하므로 해상도가 커져도 그래픽을 수학적으로 계산하므로 깨지지 않고 잘 표현된다. 간단한 이미지(아이콘)를 표현할 때 주로 쓴다.


SVG 사이즈를 원하는데로 변경하는건 굉장히 복잡하다. 단순히 이미지처럼 width/height 값만 지정해 준다고 되는것이 아니다. 두가지 개념을 확실하게 알아야 한다.

- 뷰포트(`viewport`)
svg 요소의 `width`, `height`속성으로 설정하는 영역으로, svg의 가시 영역이다. 아래의 뷰박스에서 일정 비율/크기로 잘라낸 svg 영역을 뷰포트 영역 크기만큼 보여준다.

- [뷰박스(`viewbox`)](https://developer.mozilla.org/ko/docs/Web/SVG/Attribute/viewBox)
viewbox 속성은 `viewbox="min-x min-y width height"` 형태로 속성을 지정한다. svg 아이콘을 얼만큼 볼 지 지정하는것인데, min-x/y는 svg이미지(rect, path,...)에서 시작할 x,y 좌표(꼭지점)이고 여기서 width/height 크기 만큼의 사각형을 잘라서 viwport 크기에 맞춰 확대/축소하여 보여준다.

<br>

이게 말로하면 이해하기 어려워 여러가지 예제를 봐야만 알 수 있다.

1. 기본
```html
<div style="width: 50px; height: 50px; background-color: red;">50x50</div>
<div>- svg -</div>
<svg viewBox="0 0 50 50" preserveAspectRatio="xMidYMid meet">
  <rect x="0" y="0" rx="4" ry="4" width="50" height="50" style="fill:#ddd" />
</svg>
```
![예제1](https://velog.velcdn.com/images/motiveko/post/285937dd-cc7c-431d-b6a8-f413805357c9/image.png)
- 50x50 상자는 비교를 위해 넣었다.
- `rect`요소로 50x50의 정사각형을 그렸다.
- viewbox는 0,0에서 시작해 50x50 만큼이다. 이만큼 svg 내부 이미지를 보여준다는거다.
- svg에 width/height가 없다. 이렇게하면 ***기본값으로 최대 넓이만큼(부모요소)의 가로/세로 정사각형의 viewport를 가지게 된다.***(화면 영역만큼 캡쳐한 이미지다.)
- [`preserveAspectRatio`](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/preserveAspectRatio)는 좀 있다 다룬다.

<br>

2. 뷰포트 == 뷰박스 ( == 이미지 )

```html
<svg width="50" viewBox="0 0 50 50" preserveAspectRatio="xMidYMid meet">
  <rect x="0" y="0" rx="4" ry="4" width="50" height="50" style="fill:#ddd" />
</svg>
```
![예제2](https://velog.velcdn.com/images/motiveko/post/fb099f65-1bd3-4ec4-b475-6832cf4bcb29/image.png)
- svg에 `width=50`을 줬다. heigth도 알아서 50이 된다. 이렇게 하면 **뷰포트 크기와 뷰박스 크기가 같고, 뷰박스는 svg 사각형을 그대로 잘랐기 때문에 50x50 박스가 50x50크기로 그대로 보인다.**


<br>

3. 뷰포트 > 뷰박스( == 이미지)
```html
<svg width="200" viewBox="0 0 50 50" preserveAspectRatio="xMidYMid meet">
  <rect x="0" y="0" rx="4" ry="4" width="50" height="50" style="fill:#ddd" />
</svg>
```
![예제3](https://velog.velcdn.com/images/motiveko/post/a9d38ddb-166d-493c-a307-2082377f4efc/image.png)
- 뷰포트 크기를 200x200으로 잘랐다. 뷰박스에서 잘라낸 svg 사각형을 뷰포트 크기 200x200만큼 키운걸 볼 수 있다. ***뷰박스로 잘라낸걸 뷰포트크기로 확대해서 보여주는걸 알 수 있다.***

<br>

4. 뷰박스로 이미지 일부 잘라내기
```html
<svg width="200" viewBox="10 10 150 150" preserveAspectRatio="xMidYMid meet">
  <rect x="0" y="0" rx="4" ry="4" width="50" height="50" style="fill:#ddd" />
</svg>
```
![예제4](https://velog.velcdn.com/images/motiveko/post/35a99d7b-7757-4beb-8683-3ff7745a2f5d/image.png)
- 뷰박스를 통해 svg를 10,10 부터 160,160의 정사각형 크기로 잘랐다. 이러면 ***svg 일부와 그리지 않는 많은 여백을 뷰박스에 포함시키게 된다.*** 오른쪽 아래를 제외한 꼭지점 곡선이 사라진걸 알 수 있고(포함되지 않음), 전체 사각형 크기가 줄었는데, 이는 여백이 포함됬기 때문이다.

5. [`preserveAspectRatio`](https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/preserveAspectRatio)
- 이 속성은 뷰박스에서 자른 영역이 뷰포트 크기보다 크거나 작을때 뷰포트에 어떻게 표현할지를 나타내는 속성이다. x/y축으로 시작/중간/끝 점에 정렬하고, 삐져나가는걸 자를지 아니면 끼워맞출지 이런걸 정하는건데, MDN을 잘 보도록 하자.

<br>

svg 에니메이션을 공부했다가 여기까지 왔는데, svg란 생각보다 복잡하다. 이건 겉할기 수준이고 좀 더 수학적으로 사용하려면 깊게 공부해야 할 듯.

<br>

## React Router DOM LazyLoding, Auth guard
앵귤러로 개발할 땐 라우터로 페이지 이동시, 인증 통과한 사용자에게만 접근하려는 페이지의 js파일을 서버에서 받아 랜더링 할 수 있도록 할 수 있었다. ([`Lazy Loading`](https://angular.io/api/router/Route#lazy-loading), [`CanActivate`](https://angular.io/api/router/CanActivate)) 이걸 리액트에서도 할 수 있을까? 가능성을 하나씩 찾아본다.

1. [LazyLoading](https://reactrouter.com/docs/en/v6/examples/lazy-loading)
[`React.Suspense`](https://ko.reactjs.org/docs/react-api.html#reactsuspense), [`React.Lazy`](https://ko.reactjs.org/docs/code-splitting.html#reactlazy)를 합치면 컴포넌트의 Lazy Loading이 가능하다. 이걸 라우터에다가 적용하기만 하면 된다.
```tsx
import * as React from "react";
import { Routes, Route, Outlet, Link } from "react-router-dom";

const Dashboard = React.lazy(() => import("./pages/Dashboard"));

export default function App() {
  return (
      <Routes>
        <Route path="/" element={<Layout />}>
          <Route index element={<Home />} />
          <Route
            path="dashboard/*"
            element={
              <React.Suspense fallback={<>...</>}>
                <Dashboard />
              </React.Suspense>
            }
          />
        </Route>
      </Routes>
  )
}
```
공식 예제인데, Dashboard는 자식 라우트로 구성할 수 있다. path가 `dashboard/*`이므로 dashboard/... 이하는 Lazy Loading된 Dashboard에 가서 또 ...에 맞는 Route요소를 찾아서 랜더링 하게 될 것이다.

<br>

추가적으로 [`@loadable/component`](https://loadable-components.com/docs/getting-started/)같은 라이브러리도 이용할 수 있다. 컴포넌트가 `default export`가 아닌 `named export`일 경우 이런 라이브러리를 사용하면 쉬워진다. 대략 아래와 같은 문법으로 사용한다.
```ts
const About = loadable(() => import('./pages/About'), {
  resolveComponent: (components) => components.About,
});
```

<br>


## 2. [React Router Authentication](https://reactrouter.com/docs/en/v6/examples/auth)

- 이거 사용자를 비인증 사용자 /login으로 리다이렉트 시키는 예가 깔끔하다. navigate의 reaplcate의 의미를 정확히 아는게 중요할듯(아마 history api에 기록 남기는지 여부같은데.. 뒤로가기시 깔끔하게하려고)

- 라우터에 인증을 거는건 여러가지 방식이 있는 것 같은데 공식 문서 방식으로 정리한다. `ContextAPI`를 이용해서 인증 관련 함수(`signIn`, `signOut`)와 인증상태(user)를 제공한다. (보통 페이지가 여러개 있는 경우 라우트 최상위에 Private/Public Route같은걸 만들고 여기서 해당 함수/상태값을 이용해서 인증여부를 판단하게 하여 인증 라우트로 접근할지 아니면 로그인 페이지로 넘어갈지 결정한다.)
```tsx
// App.tsx
function App() {
  return (
    <AuthProvider>
      <Routes>
        <Route element={<Layout />}>
          <Route path="/" element={<PublicPage />}/>
          <Route path="/login" element={<LoginPage />}/>
          <Route 
            path="/protected"
            element={
              <RequireAuth>
                <ProtectedPage />
              </RequireAuth>
            }
          />
        </Route>
      </Routes>
    </AuthProvider>
  );
}
```
- 최상위에 `AuthProvider`를 이용해서 인증함수/상태를 전역에서 사용 가능하게 구성한다.
- Public Page들은 따로 처리가 필요없고, 인증이 필요한 페이지는 `RequireAuth` 컴포넌트로 래핑한다. 이건 아래와 같이 생겼다.
```tsx
const RequireAuth: React.FC = ({children}) => {
  let auth = useAuth();
  let location = useLocation();
  
  if(!auth.user) {
    return <Navigate to="/login" state={{ from: location }} replace />
  }
  return <>{children}</>;
}
```
- `useAuth()` 훅은 AuthProvider가 제공하는 Context를 사용할 수 있는 훅이다. 대충 아래와 같이 생긴다.
```tsx

interface AuthContextType {
  user: any;
  signin: (user: string, clalback: VoidFunction) => void;
  signout: (callback: VoidFunction) => void;
}
let AuthContext = React.createContext<AuthContextType>(null!);

const AuthProvider = ({children}: {children: React.ReactNode}) => {
  let [user, setUser] = useState<any>(null);

  let signin = (newUser: string, callback: VoidFunction) => {
    return fakeAuthProvider.signin(() => {
      setUser(newUser);
      callback();
    });
  };

  let signout = (callback: VoidFunction) => {
    return fakeAuthProvider.signout(() => {
      setUser(null);
      callback();
    });
  };
  return <AuthContext.Provider value={{user, signin, signout}}>{children}</AuthContext.Provider>
}

// AuthProvider 하위에서는 useAuth 훅을 이용해서 AuthContext를 사용할 수 있다!
const useAuth = () => {
  return useContext(AuthContext);
}
```
- `ProtectedPage`로 접근하게 되면 `RequireAuth` 컴포넌트를 통해 `user` 상태값이 있는지(인증여부) 확인하고, 없으면 `LoginPage`로, 있으면 `ProtectedPage`를 랜더링한다. 하위 페이지를 childern이 아니라 Route로 구성하게 되면 쪼개게 되면 `<Outlet />`을 랜더링 하면 된다.

<br>

<!-- TODO : ReactRouter에서 Multiapp(https://reactrouter.com/docs/en/v6/examples/multi-app) 부분 신기한데 정리해보기 -->