# [The main thread is overworked & underpaid (Chrome Dev Summit 2019)](dassur.ma/things/react-redux-comlink)
 
> 싱글 스레드인 자바스크립트의 메인스레드의 멀티스레드 동작에 관하여..

<br>

## 1. js는 기본 싱글스레드다
- I/O 작업은 여러 다른 스레드에서 동작한다.
- js 코드의 동기 코드를 사용하는 부분은 모두 싱글(메인)스레드에서 동작하고 블로킹된다. => UI는 메인스레드에서 동작하고 블로킹된다.

<br>

## 2. 주사율과 성능
- 60hz를 유지하려면 유저 이벤트가 발생하면  js코드실행/style/layout/paint/compositing... 하는 과정이 메인 스레드에서 16.7ms내에 일어나야한다. 
- 90hz/120hs/144hz... 로 갈 수록 이 시간은 더 가혹해진다. 
- iphone pro같은 좋은 폰을 쓰는 사람들은 내가 쓴 코드가 높은 주사율로 돌아간다. 성능이 좋기 때문. 하지만 전 세계적으로는 아이폰같은 하이엔드 폰보다는 motorora나 nokia같은 매우 후진 폰을 쓰는 사람이 많다. 이런 사람들에게서도 좋은 UX를 제공하고 싶다.

<br>

## 3. 멀티스레드
- 웹의 JS에서 멀티스레드를 위해 [`Web Worker`](https://www.npmjs.com/package/comlink)를 지원한다.(node에서는 `worker_thread`) 이게 그냥 쓰기는 좀 코드가 복잡해지는게 있는데, 구글 랩에서 comlink라는 라이브러리를 제공해, Web Worker를 쓰기 쉽게 추상화 해준다.
- 웹 워커는 메시지 패턴을 이용해서 메인 스레드와 워커스레드가 상호작용 한다.(`worker.postMessage()`)
- IOS나 Android는 멀티스레드로 동작한다. 이 때, UI에 접근할 수 있는건 메인스레드 뿐이다. 이로 인해 **메인 쓰레드를 UI 쓰레드라고 부르기도 한다.**
- 이건 JS도 마찬가지다. ***Web Worker로 만든 스레드에서는 DOM에 접근할 수 없다!***
- ### 이런 부분을 고려하면 ***UI 조작은 메인스레드에서, 비즈니스 로직은 Worker 스레드에서 처리해야 한다는 결론을 얻을 수 있다.***

<br>

## 4. FLUX 패턴
- FLUX 패턴은 UI와 비즈니스 로직을 잘 구분한 좋은 패턴이다. UI 컴포넌트에서는 UI만 신경쓰고, 유저 인터렉션에 따라 `action`만 `dispatch`한다. 이 액션에 맞는 비즈니스 로직이 수행되는건 `Store`다.
- UI는 그대로 두고 Store 코드만 워커 스레드에서 동작한다면? 워커에서 여러 블로킹 작업을 수행하고, UI는 결과를 가지고 DOM 조작만 하는것이다. => 멀티스레드가 잘 동작할 수 있는 패턴이다!
- 이런점을 잘 살려서 [`comlink`와 `react-redux`를 결합하여 사용할 수 있는 방법](https://dassur.ma/things/react-redux-comlink)에 대해서도 정리되어 있다.
- 워커와 메인스레드간 통신에는 분명 오버헤드가 발생하긴 한다.(메인스레드 블록) 하지만 전체 비즈니스 로직을 메인스레드에서 실행하는 동안의 블로킹에 비하면 이는 감내할 수 있는 수준일것이다. => 이걸 잘 생각해보면 너무 가벼운 작업은 굳이 멀티스레드로 실행하지 않는게 낫다는 것이기도 하다. 불필요한 오버헤드를 일으킬 필요는 없다.

<br>

## 5. 오버헤드
- `postMessage`로 워커 -> 메인스레드로 데이터를 보내는 과정은 데이터의 복사가 필요하다. 이를 `destructured cloning`이라고 한다.
- 꾸진 nokia 폰 기준, 10mb를 transfer 하는데 600ms 가 넘게 걸린다.(이정도를 보내는 경우는 흔치 않을것이다.)
- 이 시간이 문제가 된다면 `SharedArrayBuffer`를 이용해서 `ArrayBuffer`를 전송하거나 `WebAssembly`를 쓰면 더 빠르게 데이터 공유가 가능하다고 한다.
- 이와 관련한 벤치마크나 대체 방법에 대한 정리된 [포스팅](https://surma.dev/things/is-postmessage-slow/)도 있다.

<br>

## 6. 정리..
- **멀티스레드 사용하는게 전체 성능을 올린다는건 아니다. 오히려 비즈니스 로직이 완료되는 시점을 늦추는 결과가 될 수 있다. (왜냐면 워커 스레드는 메인스레드보다 느리기 때문)**
- 하지만 워커스레드에서 블로킹 로직을 처리하는 동안 메인 스레드는 여전히 UI를 관리할 수 있어 화면이 멈추지 않고 여러가지 인터렉션을 해줄 수 있다. 전체 실행 시간은 늘어도 높은 주사율을 유지하고 유저와의 인터렉션을 끊기지 않게 할 수 있는것이다!